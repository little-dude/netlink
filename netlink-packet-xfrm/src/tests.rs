// SPDX-License-Identifier: MIT

use std::net::{Ipv4Addr, Ipv6Addr};
use std::str::FromStr;

use crate::{
    constants::*,
    Address,
    AsyncEventId,
    EncapTmpl,
    Id,
    Lifetime,
    LifetimeConfig,
    Mark,
    GetAsyncEventMessage,
    MappingMessage,
    MigrateMessage,
    ReportMessage,
    NetlinkHeader,
    NetlinkMessage,
    policy::FlushMessage,
    policy::ModifyMessage,
    SadInfoAttrs::*,
    Selector,
    SpdInfoAttrs::*,
    UserKmAddress,
    UserMapping,
    UserMigrate,
    UserPolicyId,
    UserPolicyInfo,
    UserPolicyType,
    UserReport,
    UserSaId,
    UserTemplate,
    XfrmAttrs,
    XfrmAttrs::*,
    XfrmMessage,
};

use netlink_packet_core::*;
use netlink_proto::sys::protocols::NETLINK_XFRM;
use netlink_sys::{Socket, SocketAddr};


#[test]
fn parse_xfrm_pol_1() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P1_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::FlushPolicy(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }
}

#[test]
fn emit_xfrm_pol_1() {
    let mut buf = vec![0; P1_BYTES.len()];

    let mut packet = NetlinkMessage {
        header: NetlinkHeader {
            sequence_number: 1650675114,
            flags: NLM_F_REQUEST | NLM_F_ACK,
            ..Default::default()
        },
        payload: XfrmMessage::FlushPolicy(FlushMessage::default()).into(),
    };
    packet.finalize();
    packet.serialize(&mut buf[..]);
    println!("{:?}", packet);
    assert_eq!(&buf[..], &P1_BYTES[..]);

    //send it out kernel netlink socket to perform the actual flush (needs to be root)
    netlink_send_recv(&buf[..]);
}

#[test]
fn parse_xfrm_pol_2() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P2_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::FlushPolicy(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }
}

#[test]
fn emit_xfrm_pol_2() {
    let mut buf = vec![0; P2_BYTES.len()];
    let flush_payload = FlushMessage {
        nlas: vec![
            XfrmAttrs::PolicyType(UserPolicyType {
                ptype: XFRM_POLICY_TYPE_SUB,
                ..Default::default()
            }),
        ],
    };
    let mut packet = NetlinkMessage {
        header: NetlinkHeader {
            sequence_number: 1650861160,
            flags: NLM_F_REQUEST | NLM_F_ACK,
            ..Default::default()
        },
        payload: XfrmMessage::FlushPolicy(flush_payload).into(),
    };
    packet.finalize();
    packet.serialize(&mut buf[..]);
    println!("{:?}", packet);
    assert_eq!(&buf[..], &P2_BYTES[..]);

    //send it out kernel netlink socket to perform the actual flush (needs to be root)
    netlink_send_recv(&buf[..]);
}

#[test]
fn parse_xfrm_pol_3() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P3_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::AddPolicy(xm)) => {
            // Check some of the expected values, any errors in calculating
            // struct sizes, field offsets, value endian-ness, etc.
            // could show up here.
            assert_eq!(xm.user_policy_info.selector.daddr.addr[0..4], [172, 16, 0, 0]);
            assert_eq!(xm.user_policy_info.selector.daddr.to_ipv4(), Ipv4Addr::from_str("172.16.0.0").unwrap());
            assert_eq!(xm.user_policy_info.selector.saddr.addr[0..4], [10, 0, 0, 0]);
            assert_eq!(xm.user_policy_info.selector.saddr.to_ipv4(), Ipv4Addr::from_str("10.0.0.0").unwrap());
            assert_eq!(xm.user_policy_info.selector.dport, 40003);
            assert_eq!(xm.user_policy_info.selector.dport_mask, 0xFFFF);
            assert_eq!(xm.user_policy_info.selector.sport, 20007);
            assert_eq!(xm.user_policy_info.selector.sport_mask, 0xFFFF);
            assert_eq!(xm.user_policy_info.selector.family, AF_INET);
            assert_eq!(xm.user_policy_info.selector.prefixlen_d, 24);
            assert_eq!(xm.user_policy_info.selector.prefixlen_s, 24);
            assert_eq!(xm.user_policy_info.selector.proto, IPPROTO_TCP);
            assert_eq!(xm.user_policy_info.selector.ifindex, 2);
            assert_eq!(xm.user_policy_info.selector.user, 0);

            assert_eq!(xm.user_policy_info.lifetime_cfg.soft_byte_limit, 0xFFFFFFFFFFFFFFFF);
            assert_eq!(xm.user_policy_info.lifetime_cfg.hard_byte_limit, 0xFFFFFFFFFFFFFFFF);
            assert_eq!(xm.user_policy_info.lifetime_cfg.soft_packet_limit, 0xFFFFFFFFFFFFFFFF);
            assert_eq!(xm.user_policy_info.lifetime_cfg.hard_packet_limit, 0xFFFFFFFFFFFFFFFF);
            assert_eq!(xm.user_policy_info.lifetime_cfg.soft_add_expires_seconds, 0);
            assert_eq!(xm.user_policy_info.lifetime_cfg.hard_add_expires_seconds, 0);
            assert_eq!(xm.user_policy_info.lifetime_cfg.soft_use_expires_seconds, 0);
            assert_eq!(xm.user_policy_info.lifetime_cfg.hard_use_expires_seconds, 0);

            assert_eq!(xm.user_policy_info.lifetime_cur.bytes, 0);
            assert_eq!(xm.user_policy_info.lifetime_cur.packets, 0);
            assert_eq!(xm.user_policy_info.lifetime_cur.add_time, 0);
            assert_eq!(xm.user_policy_info.lifetime_cur.use_time, 0);

            assert_eq!(xm.user_policy_info.priority, 100);
            assert_eq!(xm.user_policy_info.index, 1);
            assert_eq!(xm.user_policy_info.direction, XFRM_POLICY_OUT);
            assert_eq!(xm.user_policy_info.action, XFRM_POLICY_ALLOW);
            assert_eq!(xm.user_policy_info.flags, XFRM_POLICY_LOCALOK);
            assert_eq!(xm.user_policy_info.share, XFRM_SHARE_ANY);

            // iterate attributes
            for attr in xm.nlas.iter() {
                match attr {
                    PolicyType(up) => assert_eq!(up.ptype, XFRM_POLICY_TYPE_SUB),
                    Template(ut) => {
                        assert_eq!(ut[0].id.daddr.addr[0..4], [198, 51, 100, 20]);
                        assert_eq!(ut[0].id.daddr.to_ipv4(), Ipv4Addr::from_str("198.51.100.20").unwrap());
                        assert_eq!(ut[0].id.spi, 0);
                        assert_eq!(ut[0].id.proto, IPPROTO_ESP);
                        assert_eq!(ut[0].family, AF_INET);
                        assert_eq!(ut[0].saddr.addr[0..4], [192, 0, 2, 1]);
                        assert_eq!(ut[0].saddr.to_ipv4(), Ipv4Addr::from_str("192.0.2.1").unwrap());
                        assert_eq!(ut[0].reqid, 1);
                        assert_eq!(ut[0].mode, XFRM_MODE_TUNNEL);
                        assert_eq!(ut[0].share, XFRM_SHARE_ANY);
                        assert_eq!(ut[0].optional, 0);
                        assert_eq!(ut[0].aalgos, 0xFFFFFFFF);
                        assert_eq!(ut[0].ealgos, 0xFFFFFFFF);
                        assert_eq!(ut[0].calgos, 0xFFFFFFFF);
                    },
                    Mark(mark) => {
                        assert_eq!(mark.value, 8);
                        assert_eq!(mark.mask, 3);
                    },
                    IfId(ifid) => assert_eq!(*ifid, 5),
                    _ => {
                        panic!("unexpected XfrmAttr");
                    }
                }
            }
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }
}

#[test]
fn emit_xfrm_pol_3() {
    let mut buf = vec![0; P3_BYTES.len()];

    let upt = UserPolicyType {
        ptype: XFRM_POLICY_TYPE_SUB,
        reserved1: 0,
        reserved2: 0
    };

    let ut = UserTemplate {
        id: Id {
                daddr: Address::from_ipv4(&Ipv4Addr::from_str("198.51.100.20").unwrap()),
                spi: 0,
                proto: IPPROTO_ESP
        },
        family: AF_INET,
        saddr: Address::from_ipv4(&Ipv4Addr::from_str("192.0.2.1").unwrap()),
        reqid: 1,
        mode: XFRM_MODE_TUNNEL,
        share: XFRM_SHARE_ANY,
        optional: 0,
        aalgos: 0xFFFFFFFF,
        ealgos: 0xFFFFFFFF,
        calgos: 0xFFFFFFFF
    };

    let mark = Mark {
        value: 8,
        mask: 3
    };

    let modify_payload = ModifyMessage {
        user_policy_info: UserPolicyInfo {
            selector: Selector {
                daddr: Address::from_ipv4(&Ipv4Addr::from_str("172.16.0.0").unwrap()),
                saddr: Address::from_ipv4(&Ipv4Addr::from_str("10.0.0.0").unwrap()),
                dport: 40003,
                dport_mask: 0xFFFF,
                sport: 20007,
                sport_mask: 0xFFFF,
                family: AF_INET,
                prefixlen_d: 24,
                prefixlen_s: 24,
                proto: IPPROTO_TCP,
                ifindex: 2,
                user: 0,
            },

            lifetime_cfg: LifetimeConfig {
                soft_byte_limit: 0xFFFFFFFFFFFFFFFF,
                hard_byte_limit: 0xFFFFFFFFFFFFFFFF,
                soft_packet_limit: 0xFFFFFFFFFFFFFFFF,
                hard_packet_limit: 0xFFFFFFFFFFFFFFFF,
                soft_add_expires_seconds: 0,
                hard_add_expires_seconds: 0,
                soft_use_expires_seconds: 0,
                hard_use_expires_seconds: 0,
            },

            lifetime_cur: Lifetime {
                bytes: 0,
                packets: 0,
                add_time: 0,
                use_time: 0,
            },

            priority: 100,
            index: 1,
            direction: XFRM_POLICY_OUT,
            action: XFRM_POLICY_ALLOW,
            flags: XFRM_POLICY_LOCALOK,
            share: XFRM_SHARE_ANY,
        },
        nlas: vec![
            XfrmAttrs::PolicyType(upt),
            XfrmAttrs::Template(vec![ut]),
            XfrmAttrs::Mark(mark),
            XfrmAttrs::IfId(5)
        ],
    };
    let mut packet = NetlinkMessage {
        header: NetlinkHeader {
            sequence_number: 1652078034,
            flags: NLM_F_REQUEST | NLM_F_ACK,
            ..Default::default()
        },
        payload: XfrmMessage::AddPolicy(modify_payload).into(),
    };
    packet.finalize();
    packet.serialize(&mut buf[..]);
    println!("{:?}", packet);
    assert_eq!(&buf[..], &P3_BYTES[..]);

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_4() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P4_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P4_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::UpdatePolicy(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }
}

#[test]
fn parse_xfrm_pol_5() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P5_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::AddPolicy(xm)) => {
            assert_eq!(xm.user_policy_info.selector.daddr.to_ipv6(), Ipv6Addr::from_str("fe88::172.16.0.0").unwrap());
            assert_eq!(xm.user_policy_info.selector.saddr.to_ipv6(), Ipv6Addr::from_str("fe88::10.0.0.0").unwrap());
            assert_eq!(xm.user_policy_info.selector.dport, 40003);
            assert_eq!(xm.user_policy_info.selector.dport_mask, 0xFFFF);
            assert_eq!(xm.user_policy_info.selector.sport, 20007);
            assert_eq!(xm.user_policy_info.selector.sport_mask, 0xFFFF);
            assert_eq!(xm.user_policy_info.selector.family, AF_INET6);
            assert_eq!(xm.user_policy_info.selector.prefixlen_d, 64);
            assert_eq!(xm.user_policy_info.selector.prefixlen_s, 64);
            assert_eq!(xm.user_policy_info.selector.proto, IPPROTO_TCP);
            assert_eq!(xm.user_policy_info.selector.ifindex, 2);
            assert_eq!(xm.user_policy_info.selector.user, 0);

            assert_eq!(xm.user_policy_info.lifetime_cfg.soft_byte_limit, 0xFFFFFFFFFFFFFFFF);
            assert_eq!(xm.user_policy_info.lifetime_cfg.hard_byte_limit, 0xFFFFFFFFFFFFFFFF);
            assert_eq!(xm.user_policy_info.lifetime_cfg.soft_packet_limit, 0xFFFFFFFFFFFFFFFF);
            assert_eq!(xm.user_policy_info.lifetime_cfg.hard_packet_limit, 0xFFFFFFFFFFFFFFFF);
            assert_eq!(xm.user_policy_info.lifetime_cfg.soft_add_expires_seconds, 0);
            assert_eq!(xm.user_policy_info.lifetime_cfg.hard_add_expires_seconds, 0);
            assert_eq!(xm.user_policy_info.lifetime_cfg.soft_use_expires_seconds, 0);
            assert_eq!(xm.user_policy_info.lifetime_cfg.hard_use_expires_seconds, 0);

            assert_eq!(xm.user_policy_info.lifetime_cur.bytes, 0);
            assert_eq!(xm.user_policy_info.lifetime_cur.packets, 0);
            assert_eq!(xm.user_policy_info.lifetime_cur.add_time, 0);
            assert_eq!(xm.user_policy_info.lifetime_cur.use_time, 0);

            assert_eq!(xm.user_policy_info.priority, 100);
            assert_eq!(xm.user_policy_info.index, 1);
            assert_eq!(xm.user_policy_info.direction, XFRM_POLICY_OUT);
            assert_eq!(xm.user_policy_info.action, XFRM_POLICY_ALLOW);
            assert_eq!(xm.user_policy_info.flags, XFRM_POLICY_LOCALOK);
            assert_eq!(xm.user_policy_info.share, XFRM_SHARE_ANY);

            // iterate attributes
            for attr in xm.nlas.iter() {
                match attr {
                    PolicyType(up) => assert_eq!(up.ptype, XFRM_POLICY_TYPE_SUB),
                    Template(ut) => {
                        assert_eq!(ut[0].id.daddr.to_ipv6(), Ipv6Addr::from_str("fe68::198.51.100.20").unwrap());
                        assert_eq!(ut[0].id.spi, 0);
                        assert_eq!(ut[0].id.proto, IPPROTO_ESP);
                        assert_eq!(ut[0].family, AF_INET6);
                        assert_eq!(ut[0].saddr.to_ipv6(), Ipv6Addr::from_str("fe68::192.0.2.1").unwrap());
                        assert_eq!(ut[0].reqid, 1);
                        assert_eq!(ut[0].mode, XFRM_MODE_TUNNEL);
                        assert_eq!(ut[0].share, XFRM_SHARE_ANY);
                        assert_eq!(ut[0].optional, 0);
                        assert_eq!(ut[0].aalgos, 0xFFFFFFFF);
                        assert_eq!(ut[0].ealgos, 0xFFFFFFFF);
                        assert_eq!(ut[0].calgos, 0xFFFFFFFF);
                    },
                    Mark(mark) => {
                        assert_eq!(mark.value, 8);
                        assert_eq!(mark.mask, 3);
                    },
                    IfId(ifid) => assert_eq!(*ifid, 5),
                    _ => {
                        panic!("unexpected XfrmAttr");
                    }
                }
            }
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }
}

#[test]
fn emit_xfrm_pol_5() {
    let mut buf = vec![0; P5_BYTES.len()];

    let upt = UserPolicyType {
        ptype: XFRM_POLICY_TYPE_SUB,
        reserved1: 0,
        reserved2: 0
    };

    let ut = UserTemplate {
        id: Id {
                daddr: Address::from_ipv6(&Ipv6Addr::from_str("fe68::198.51.100.20").unwrap()),
                spi: 0,
                proto: IPPROTO_ESP
        },
        family: AF_INET6,
        saddr: Address::from_ipv6(&Ipv6Addr::from_str("fe68::192.0.2.1").unwrap()),
        reqid: 1,
        mode: XFRM_MODE_TUNNEL,
        share: XFRM_SHARE_ANY,
        optional: 0,
        aalgos: 0xFFFFFFFF,
        ealgos: 0xFFFFFFFF,
        calgos: 0xFFFFFFFF
    };

    let mark = Mark {
        value: 8,
        mask: 3
    };

    let modify_payload = ModifyMessage {
        user_policy_info: UserPolicyInfo {
            selector: Selector {
                daddr: Address::from_ipv6(&Ipv6Addr::from_str("fe88::172.16.0.0").unwrap()),
                saddr: Address::from_ipv6(&Ipv6Addr::from_str("fe88::10.0.0.0").unwrap()),
                dport: 40003,
                dport_mask: 0xFFFF,
                sport: 20007,
                sport_mask: 0xFFFF,
                family: AF_INET6,
                prefixlen_d: 64,
                prefixlen_s: 64,
                proto: IPPROTO_TCP,
                ifindex: 2,
                user: 0,
            },

            lifetime_cfg: LifetimeConfig {
                soft_byte_limit: 0xFFFFFFFFFFFFFFFF,
                hard_byte_limit: 0xFFFFFFFFFFFFFFFF,
                soft_packet_limit: 0xFFFFFFFFFFFFFFFF,
                hard_packet_limit: 0xFFFFFFFFFFFFFFFF,
                soft_add_expires_seconds: 0,
                hard_add_expires_seconds: 0,
                soft_use_expires_seconds: 0,
                hard_use_expires_seconds: 0,
            },

            lifetime_cur: Lifetime {
                bytes: 0,
                packets: 0,
                add_time: 0,
                use_time: 0,
            },

            priority: 100,
            index: 1,
            direction: XFRM_POLICY_OUT,
            action: XFRM_POLICY_ALLOW,
            flags: XFRM_POLICY_LOCALOK,
            share: XFRM_SHARE_ANY,
        },
        nlas: vec![
            XfrmAttrs::PolicyType(upt),
            XfrmAttrs::Template(vec![ut]),
            XfrmAttrs::Mark(mark),
            XfrmAttrs::IfId(5)
        ],
    };
    let mut packet = NetlinkMessage {
        header: NetlinkHeader {
            sequence_number: 1658818497,
            flags: NLM_F_REQUEST | NLM_F_ACK,
            ..Default::default()
        },
        payload: XfrmMessage::AddPolicy(modify_payload).into(),
    };
    packet.finalize();
    packet.serialize(&mut buf[..]);
    println!("{:?}", packet);
    assert_eq!(&buf[..], &P5_BYTES[..]);

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_6() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P6_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P6_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::DeletePolicy(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_7() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P7_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P7_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::GetPolicy(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_8() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P8_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P8_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::AddPolicy(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_9() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P9_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P9_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::GetSpdInfo(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_10() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P10_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P10_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::NewSpdInfo(xm)) => {
            println!("{:?}", xm);

            // iterate attributes
            for attr in xm.nlas.iter() {
                match attr {
                    SpdInfo(si) => {
                        assert_eq!(si.incnt, 0);
                        assert_eq!(si.outcnt, 1);
                    },
                    SpdHInfo(si) => {
                        assert_eq!(si.spdhcnt, 7);
                        assert_eq!(si.spdhmcnt, 1048576);
                    },
                    SpdIpv4HThresh(si) => {
                        assert_eq!(si.lbits, 32);
                        assert_eq!(si.rbits, 32);
                    },
                    SpdIpv6HThresh(si) => {
                        assert_eq!(si.lbits, 128);
                        assert_eq!(si.rbits, 128);
                    },
                    _ => {
                        panic!("unexpected SpdInfoAttrs");
                    }
                }
            }
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_11() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P11_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P11_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::GetPolicyDefault(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_12() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P12_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; P12_BYTES.len()]; // the sample packet has one extra byte of padding that isn't parsed
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P12_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::GetPolicyDefault(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_13() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P13_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P13_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::SetPolicyDefault(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_pol_14() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&P14_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &P14_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::AddPolicy(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_1() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S1_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S1_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::AddSa(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_2() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S2_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S2_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::UpdateSa(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_3() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S3_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S3_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::GetSa(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_4() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S4_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S4_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::AddSa(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_5() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S5_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S5_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::DeleteSa(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_6() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S6_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S6_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::FlushSa(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_7() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S7_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S7_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::GetSadInfo(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_8() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S8_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S8_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::NewSadInfo(xm)) => {
            println!("{:?}", xm);
            // iterate attributes
            for attr in xm.nlas.iter() {
                match attr {
                    SadCount(si) => assert_eq!(*si, 1),
                    SadHInfo(si) => {
                        println!("{:?}", si);
                        assert_eq!(si.sadhcnt, 8);
                        assert_eq!(si.sadhmcnt, 1048576);
                    },
                    _ => {
                        panic!("unexpected SadInfoAttrs");
                    }
                }
            }
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_9() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S9_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S9_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::AllocSpi(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_st_10() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&S10_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &S10_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::AddSa(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_mon_1() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&M1_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &M1_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::Expire(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_mon_2() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&M2_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &M2_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::PolicyExpire(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_mon_3() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&M3_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &M3_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::Acquire(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn emit_xfrm_mon_4() {
    let mut buf = vec![0; 256];

    let get_async_payload = GetAsyncEventMessage {
        id: AsyncEventId {
            sa_id: UserSaId {
                daddr: Address::from_ipv4(&Ipv4Addr::from_str("172.16.1.1").unwrap()),
                spi: 0x12345678,
                family: AF_INET,
                proto: IPPROTO_ESP,
            },
            saddr: Address::from_ipv4(&Ipv4Addr::from_str("10.10.10.1").unwrap()),
            flags: 255,
            reqid: 0,
        },
    };

    let mut packet = NetlinkMessage {
        header: NetlinkHeader {
            sequence_number: 0,
            flags: NLM_F_REQUEST | NLM_F_ACK,
            ..Default::default()
        },
        payload: XfrmMessage::GetAsyncEvent(get_async_payload).into(),
    };
    packet.finalize();
    packet.serialize(&mut buf[..]);
    println!("{:?}", packet);
    assert_eq!(&buf[..packet.buffer_len()], &M4_BYTES[..]);

    //netlink_send_recv(&buf[..packet.buffer_len()]);
}

#[test]
fn parse_emit_xfrm_mon_4() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&M4_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &M4_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::GetAsyncEvent(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn parse_emit_xfrm_mon_5() {
    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&M5_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    let mut buf = vec![0; deserialized_packet.buffer_len()];
    //reserialize
    deserialized_packet.serialize(&mut buf[..]);
    assert_eq!(&buf[..], &M5_BYTES[..]);

    match deserialized_packet.into_parts().1 {
        NetlinkPayload::InnerMessage(XfrmMessage::NewAsyncEvent(xm)) => {
            println!("{:?}", xm);
        }
        _ => {
            panic!("unhandled NetlinkPayload variant");
        }
    }

    //netlink_send_recv(&buf[..]);
}

#[test]
fn emit_parse_xfrm_mon_6() {
    let mut buf = vec![0; 256];

    let report_payload = ReportMessage {
        report: UserReport {
            proto: IPPROTO_ESP,
            selector: Selector {
                daddr: Address::from_ipv4(&Ipv4Addr::from_str("172.16.0.0").unwrap()),
                saddr: Address::from_ipv4(&Ipv4Addr::from_str("10.0.0.0").unwrap()),
                dport: 40003,
                dport_mask: 0xFFFF,
                sport: 20007,
                sport_mask: 0xFFFF,
                family: AF_INET,
                prefixlen_d: 24,
                prefixlen_s: 24,
                proto: IPPROTO_TCP,
                ifindex: 2,
                user: 0,
            },
        },
        nlas: vec![
            XfrmAttrs::CareOfAddr(
                Address::from_ipv4(&Ipv4Addr::from_str("192.168.1.1").unwrap())
                ),
        ],
    };

    let mut packet = NetlinkMessage {
        header: NetlinkHeader {
            sequence_number: 0,
            flags: NLM_F_REQUEST | NLM_F_ACK,
            ..Default::default()
        },
        payload: XfrmMessage::Report(report_payload).into(),
    };
    packet.finalize();
    packet.serialize(&mut buf[..]);
    println!("{:?}", packet);
    assert_eq!(&buf[..packet.buffer_len()], &M6_BYTES[..]);

    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&M6_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    assert_eq!(packet, deserialized_packet);

    //netlink_send_recv(&buf[..packet.buffer_len()]);
}

#[test]
fn emit_parse_xfrm_mon_7() {
    let mut buf = vec![0; 256];

    let mapping_payload = MappingMessage {
        map: UserMapping {
            id: UserSaId {
                daddr: Address::from_ipv4(&Ipv4Addr::from_str("172.16.1.1").unwrap()),
                spi: 0x12345678,
                family: AF_INET,
                proto: IPPROTO_ESP,
            },
            reqid: 123,
            old_saddr: Address::from_ipv4(&Ipv4Addr::from_str("192.168.1.1").unwrap()),
            new_saddr: Address::from_ipv4(&Ipv4Addr::from_str("192.168.2.1").unwrap()),
            old_sport: 40003,
            new_sport: 20007,
        }
    };

    let mut packet = NetlinkMessage {
        header: NetlinkHeader {
            sequence_number: 0,
            flags: NLM_F_REQUEST | NLM_F_ACK,
            ..Default::default()
        },
        payload: XfrmMessage::Mapping(mapping_payload).into(),
    };
    packet.finalize();
    packet.serialize(&mut buf[..]);
    println!("{:?}", packet);
    assert_eq!(&buf[..packet.buffer_len()], &M7_BYTES[..]);

    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&M7_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    assert_eq!(packet, deserialized_packet);

    //netlink_send_recv(&buf[..packet.buffer_len()]);
}

#[test]
fn emit_parse_xfrm_mon_8() {
    let mut buf = vec![0; 256];

    let migrate_payload = MigrateMessage {
        user_policy_id: UserPolicyId::default(),
        nlas: vec![
            XfrmAttrs::EncapsulationTemplate(EncapTmpl::default()),
            XfrmAttrs::KmAddress(UserKmAddress::default()),
            XfrmAttrs::Migrate(UserMigrate::default()),
            XfrmAttrs::PolicyType(UserPolicyType::default()),
        ],
    };

    let mut packet = NetlinkMessage {
        header: NetlinkHeader {
            sequence_number: 0,
            flags: NLM_F_REQUEST | NLM_F_ACK,
            ..Default::default()
        },
        payload: XfrmMessage::Migrate(migrate_payload).into(),
    };
    packet.finalize();
    packet.serialize(&mut buf[..]);
    println!("{:?}", packet);
    assert_eq!(&buf[..packet.buffer_len()], &M8_BYTES[..]);

    let deserialized_packet = NetlinkMessage::<XfrmMessage>::deserialize(&M8_BYTES).expect("Failed to deserialize message");
    println!("{:?}", deserialized_packet);
    assert_eq!(packet, deserialized_packet);

    //netlink_send_recv(&buf[..packet.buffer_len()]);
}


// Copied from documentation, needs to be run with admin/root permissions
fn netlink_send_recv(pkt: &[u8]) {
    // open a new socket for the NETLINK_XFRM subsystem
    let socket = Socket::new(NETLINK_XFRM).unwrap();
    // address of the remote peer we'll send a message to. This particular address is for the kernel
    let kernel_addr = SocketAddr::new(0, 0);
    // send the message to the kernel
    let n_sent = socket.send_to(&pkt[..], &kernel_addr, 0).unwrap();
    assert_eq!(n_sent, pkt.len());
    // buffer for receiving the response
    let mut buf = vec![0; 4096];
    loop {
        // receive a datagram
        let (n_received, sender_addr) = socket.recv_from(&mut &mut buf[..], 0).unwrap();
        assert_eq!(sender_addr, kernel_addr);
        println!("received datagram {:?}", &buf[..n_received]);
        if buf[4] == 2 && buf[5] == 0 {
            println!("the kernel responded with an error");
            return;
        }
        if buf[4] == 3 && buf[5] == 0 {
            println!("end of dump");
            return;
        }
    }
}

lazy_static! {

    //
    // XFRM policy examples
    //

    // Policy Flush (0x1d)
    static ref P1_BYTES: Vec<u8> = vec![
        0x10, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x05, 0x00, 0xaa, 0x4d, 0x63, 0x62, 0x00, 0x00, 0x00, 0x00,
    ];

    // Policy Flush (0x1d) with Policy Type 'sub' (0x01) Attribute
    static ref P2_BYTES: Vec<u8> = vec![
        0x1c, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x05, 0x00, 0x68, 0x24, 0x66, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x0a, 0x00, /* attr len */ 0x10, 0x00, /* attr type XFRMA_POLICY_TYPE */ 0x01, /* XFRM_POLICY_TYPE_SUB */
        0x00, 0x00, /* reserved1 */ 0x00, /* reserved2 */ 0x00, 0x00, 0x00, 0x00, /* padding */
    ];

    // Policy Add (0x13)
    // ip xfrm policy add src 10.0.0.0/24 dst 172.16.0.0/24 dev enp2s0f0 proto tcp sport 20007 dport 40003
    // dir out mark 8 mask 3 index 1 ptype sub action allow priority 100 flag localok if_id 5 tmpl src 192.0.2.1
    // dst 198.51.100.20 proto esp reqid 1 mode tunnel
    static ref P3_BYTES: Vec<u8> = vec![
        0x1c, 0x01, 0x00, 0x00, 0x13, 0x00, 0x05, 0x00, 0xd2, 0xb5, 0x78, 0x62, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9c, 0x43, 0xff, 0xff, 0x4e, 0x27, 0xff, 0xff, 0x02, 0x00, 0x18, 0x18, 0x06, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0xc6, 0x33, 0x64, 0x14, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c, 0x00, 0x15, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x1f, 0x00, 0x05, 0x00, 0x00, 0x00];

    // Policy Update (0x19 same as Add except for XFRM Message Type)
    // ip xfrm policy update src 10.0.0.0/24 dst 172.16.0.0/24 dev enp2s0f0 proto tcp sport 20007 dport 40003
    // dir out mark 8 mask 3 index 1 ptype sub action allow priority 100 flag localok if_id 5 tmpl src 192.0.2.1
    // dst 198.51.100.20 proto esp reqid 1 mode tunnel
    static ref P4_BYTES: Vec<u8> = vec![
        0x1c, 0x01, 0x00, 0x00, 0x19, 0x00, 0x05, 0x00, 0x01, 0x6f, 0x7c, 0x62, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9c, 0x43, 0xff, 0xff, 0x4e, 0x27, 0xff, 0xff, 0x02, 0x00, 0x18, 0x18, 0x06, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0xc6, 0x33, 0x64, 0x14, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c, 0x00, 0x15, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x1f, 0x00, 0x05, 0x00, 0x00, 0x00];

    // Policy Add with IPv6 addresses
    // ip xfrm policy add src fe88::10.0.0.0/64 dst fe88::172.16.0.0/64 dev enp2s0f0 proto tcp sport 20007 dport 40003
    // dir out mark 8 mask 3 index 1 ptype sub action allow priority 100 flag localok if_id 5 tmpl src fe68::192.0.2.1
    // dst fe68::198.51.100.20 proto esp reqid 1 mode tunnel
    static ref P5_BYTES: Vec<u8> = vec![
        0x1c, 0x01, 0x00, 0x00, 0x13, 0x00, 0x05, 0x00, 0xc1, 0x8f, 0xdf, 0x62, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x10, 0x00, 0x00,
        0xfe, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
        0x9c, 0x43, 0xff, 0xff, 0x4e, 0x27, 0xff, 0xff, 0x0a, 0x00, 0x40, 0x40, 0x06, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0xfe, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xc6, 0x33, 0x64, 0x14, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
        0x0a, 0x00, 0x00, 0x00, 0xfe, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xc0, 0x00, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c, 0x00, 0x15, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x1f, 0x00, 0x05, 0x00, 0x00, 0x00];

    // Policy Delete (0x14)
    // iproute2 when adding with mark and mask, Get and Delete commands return not
    // found error.
    // ip xfrm policy add src 10.0.0.0/24 dst 172.16.0.0/24 proto tcp sport 20007 dport 40003 dev enp2s0f0
    // index 1 dir out action allow priority 100 flag localok if_id 5 ptype sub tmpl src 192.0.2.1
    // dst 198.51.100.20 proto esp reqid 1 mode tunnel
    //
    // Policy added with the above command can be retrieved (get) or removed (del) with the following:
    // ip xfrm policy del index 1 dir out if_id 5 ptype sub
    static ref P6_BYTES: Vec<u8> = vec![
        0x64, 0x00, 0x00, 0x00, 0x14, 0x00, 0x05, 0x00, 0x29, 0x4a, 0x80, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x0a, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x1f, 0x00,
        0x05, 0x00, 0x00, 0x00];

    // Policy Get (0x15)
    // ip xfrm policy get index 1 dir out if_id 5 ptype sub
    static ref P7_BYTES: Vec<u8> = vec![
        0x64, 0x00, 0x00, 0x00, 0x15, 0x00, 0x01, 0x00, 0x11, 0x4a, 0x80, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x0a, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x1f, 0x00,
        0x05, 0x00, 0x00, 0x00];

    // A response to the above get. It is returned as an Add/New Policy (0x13) message type.
    static ref P8_BYTES: Vec<u8> = vec![
        0x10, 0x01, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x11, 0x4a, 0x80, 0x62, 0xd0, 0xda, 0x0f, 0x00,
        0xac, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9c, 0x43, 0xff, 0xff, 0x4e, 0x27, 0xff, 0xff, 0x02, 0x00, 0x18, 0x18, 0x06, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x4a, 0x80, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0xc6, 0x33, 0x64, 0x14,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x00, 0x10, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x1f, 0x00, 0x05, 0x00, 0x00, 0x00];

    // Get SPD Info (0x25) message request
    // ip -s -s xfrm policy count
    static ref P9_BYTES: Vec<u8> = vec![
        0x14, 0x00, 0x00, 0x00, 0x25, 0x00, 0x01, 0x00, 0x86, 0x63, 0x81, 0x62, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff];

    // New SPD Info (0x24) message response
    static ref P10_BYTES: Vec<u8> = vec![
        0x4c, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x86, 0x63, 0x81, 0x62, 0x20, 0x48, 0x10, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0c, 0x00, 0x02, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x06, 0x00, 0x03, 0x00,
        0x20, 0x20, 0x00, 0x00, 0x06, 0x00, 0x04, 0x00, 0x80, 0x80, 0x00, 0x00];

    // Get Default (0x28) message request
    static ref P11_BYTES: Vec<u8> = vec![
        0x13, 0x00, 0x00, 0x00, 0x28, 0x00, 0x01, 0x00, 0x08, 0x29, 0x8b, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00];

    // Get Default (0x28) message response
    static ref P12_BYTES: Vec<u8> = vec![
        0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x08, 0x29, 0x8b, 0x62, 0x77, 0x8f, 0x14, 0x00,
        0x02, 0x02, 0x02, 0x00];

    // Set Default (0x27) message request
    static ref P13_BYTES: Vec<u8> = vec![
        0x13, 0x00, 0x00, 0x00, 0x27, 0x00, 0x05, 0x00, 0x20, 0x16, 0x8f, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x01, 0x01];

    // Policy Add (0x13) with multiple templates (maximum is 6 in the kernel, defined by XFRM_MAX_DEPTH)
    // ip xfrm policy add src 10.0.0.0/24 dst 172.16.0.0/24 dir fwd tmpl proto esp tmpl proto ah
    // tmpl proto comp tmpl proto route2 tmpl proto hao tmpl proto esp src 192.168.1.0/24 mode tunnel
    static ref P14_BYTES: Vec<u8> = vec![
        0x3c, 0x02, 0x00, 0x00, 0x13, 0x00, 0x05, 0x00, 0x23, 0xa1, 0x2e, 0x63, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x33, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x6c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x2b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x3c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc0, 0xa8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];


    //
    // XFRM state examples
    //

    // State Add (0x10)
    // ip xfrm state add src 10.10.10.1 dst 172.16.1.1 proto esp spi 0x12345678 aead "rfc4106(gcm(aes))" 0x123456789abcdef123456789abcdef123456789a 128
    static ref S1_BYTES: Vec<u8> = vec![
        0x50, 0x01, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x20, 0x91, 0x95, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x32, 0x00, 0x00, 0x00,
        0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x60, 0x00, 0x12, 0x00, 0x72, 0x66, 0x63, 0x34, 0x31, 0x30, 0x36, 0x28, 0x67, 0x63, 0x6d, 0x28,
        0x61, 0x65, 0x73, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78,
        0x9a, 0xbc, 0xde, 0xf1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x9a];

    // State Update (0x1a)
    // ip xfrm state update
    static ref S2_BYTES: Vec<u8> = vec![
        0x60, 0x01, 0x00, 0x00, 0x1a, 0x00, 0x05, 0x00, 0x99, 0xab, 0x96, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x32, 0x00, 0x00, 0x00,
        0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x60, 0x00, 0x12, 0x00, 0x72, 0x66, 0x63, 0x34, 0x31, 0x30, 0x36, 0x28, 0x67, 0x63, 0x6d, 0x28,
        0x61, 0x65, 0x73, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78,
        0x9a, 0xbc, 0xde, 0xf1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x9a,
        0x10, 0x00, 0x0a, 0x00, 0x10, 0x27, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // State Get request (0x12)
    // ip xfrm state get src 10.10.10.1 dst 172.16.1.1 proto esp spi 0x12345678
    static ref S3_BYTES: Vec<u8> = vec![
        0x3c, 0x00, 0x00, 0x00, 0x12, 0x00, 0x01, 0x00, 0x94, 0xdf, 0x96, 0x62, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x12, 0x34, 0x56, 0x78, 0x02, 0x00, 0x32, 0x00, 0x14, 0x00, 0x0d, 0x00, 0x0a, 0x0a, 0x0a, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // A state get response (0x10) to the above request
    static ref S4_BYTES: Vec<u8> = vec![
        0x60, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x94, 0xdf, 0x96, 0x62, 0x98, 0x4e, 0x02, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x32, 0x00, 0x00, 0x00,
        0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xd0, 0xab, 0x96, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x60, 0x00, 0x12, 0x00, 0x72, 0x66, 0x63, 0x34, 0x31, 0x30, 0x36, 0x28, 0x67, 0x63, 0x6d, 0x28,
        0x61, 0x65, 0x73, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78,
        0x9a, 0xbc, 0xde, 0xf1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x9a,
        0x10, 0x00, 0x0a, 0x00, 0x10, 0x27, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // State Delete request (0x11)
    // ip xfrm state delete src 10.10.10.1 dst 172.16.1.1 proto esp spi 0x12345678
    static ref S5_BYTES: Vec<u8> = vec![
        0x3c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x05, 0x00, 0x39, 0xe4, 0x96, 0x62, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x12, 0x34, 0x56, 0x78, 0x02, 0x00, 0x32, 0x00, 0x14, 0x00, 0x0d, 0x00, 0x0a, 0x0a, 0x0a, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // State Flush request (0x1c)
    static ref S6_BYTES: Vec<u8> = vec![
        0x11, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x05, 0x00, 0xd7, 0x04, 0x97, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x32];

    // Get SAD Info (0x23)
    // ip -s -s xfrm policy count
    // ip -stats xfrm state count
    static ref S7_BYTES: Vec<u8> = vec![
        0x14, 0x00, 0x00, 0x00, 0x23, 0x00, 0x01, 0x00, 0xfc, 0x0f, 0x98, 0x62, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff];

    // New SAD Info (0x22) message response
    static ref S8_BYTES: Vec<u8> = vec![
        0x28, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0xfc, 0x0f, 0x98, 0x62, 0xac, 0xb2, 0x02, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x02, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00];

    // Alloc SPI (0x16)
    // ip xfrm state allocspi src 10.10.10.1 dst 172.16.1.1 proto esp mode transport reqid 10 seq 1 min 15000 max 20000 mark 7 mask 3
    static ref S9_BYTES: Vec<u8> = vec![
        0x04, 0x01, 0x00, 0x00, 0x16, 0x00, 0x01, 0x00, 0x5b, 0x5a, 0x99, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
        0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x0a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x98, 0x3a, 0x00, 0x00, 0x20, 0x4e, 0x00, 0x00, 0x0c, 0x00, 0x15, 0x00, 0x07, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00];

    // Alloc SPI response (0x10)
    static ref S10_BYTES: Vec<u8> = vec![
        0x0c, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x5b, 0x5a, 0x99, 0x62, 0xc6, 0xff, 0x02, 0x00,
        0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x14, 0x32, 0x00, 0x00, 0x00,
        0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x5a, 0x5a, 0x99, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0c, 0x00, 0x15, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0a, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];


    //
    // XFRM Monitor event examples
    //

    // SA state hard expire (0x18)
    static ref M1_BYTES: Vec<u8> = vec![
        0xf8, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x32, 0x00, 0x00, 0x00,
        0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xa1, 0x63, 0x9a, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // Policy hard expire (0x1b)
    static ref M2_BYTES: Vec<u8> = vec![
        0x18, 0x01, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9c, 0x43, 0xff, 0xff, 0x4e, 0x27, 0xff, 0xff, 0x02, 0x00, 0x18, 0x18, 0x06, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb, 0x0b, 0xac, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x44, 0x00, 0x05, 0x00, 0xc6, 0x33, 0x64, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0xc0, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x0a, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x1f, 0x00, 0x05, 0x00, 0x00, 0x00];

    // Acquire message (0x17)
    static ref M3_BYTES: Vec<u8> = vec![
        0x78, 0x01, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x08, 0xff, 0xff,
        0x02, 0x00, 0x20, 0x20, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0a, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x26, 0xad, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x00, 0x10, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // Get Async Event message (0x1f)
    static ref M4_BYTES: Vec<u8> = vec![
        0x40, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x12, 0x34, 0x56, 0x78, 0x02, 0x00, 0x32, 0x00, 0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // New Async Event message (0x1e)
    static ref M5_BYTES: Vec<u8> = vec![
        0x84, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x12, 0x34, 0x56, 0x78, 0x02, 0x00, 0x32, 0x00, 0x0a, 0x0a, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x0a, 0x00, 0xa8, 0x61, 0x00, 0x00, 0xa8, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x24, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0xb1, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0c, 0x00,
        0x0a, 0x00, 0x00, 0x00];

    // Report Event message (0x20)
    // TODO: Obtain a real, kernel-generated sample packet.
    // This payload was generated by emitting a MonitorReportMessage.
    static ref M6_BYTES: Vec<u8> = vec![
        0x60, 0x00, 0x00, 0x00, 0x20, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x32, 0x00, 0x00, 0x00, 0xac, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x9c, 0x43, 0xff, 0xff, 0x4e, 0x27, 0xff, 0xff, 0x02, 0x00, 0x18, 0x18,
        0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x0e, 0x00,
        0xc0, 0xa8, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // Mapping Event message (0x26)
    // TODO: Obtain a real, kernel-generated sample packet.
    // This payload was generated by emitting a MonitorMappingMessage.
    static ref M7_BYTES: Vec<u8> = vec![
        0x50, 0x00, 0x00, 0x00, 0x26, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xac, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x12, 0x34, 0x56, 0x78, 0x02, 0x00, 0x32, 0x00, 0x7b, 0x00, 0x00, 0x00, 0xc0, 0xa8, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xa8, 0x02, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x43, 0x4e, 0x27];

    // A Migrate Event message (0x21)
    // TODO: Obtain a real, kernel-generated sample packet.
    // This payload was generated by emitting a MonitorMigrateMessage.
    static ref M8_BYTES: Vec<u8> = vec![
        0xf4, 0x00, 0x00, 0x00, 0x21, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x1c, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x13, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00];

}
